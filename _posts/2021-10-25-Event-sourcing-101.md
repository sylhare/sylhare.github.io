---
layout: post 
title: Event sourcing 101 
color: rgb(117, 81, 57)
tags: [database]
---

Speaking about [Event sourcing][1] is speaking about an architecture pattern: the _[Event-driven architecture][2]_. It
has become a more common as solution with specialised db like [EventStoreDB][3], [Kafka][4] and other new tools that
makes it easier to apply at scale.

You can find some reference on [Microsoft Azure docs][5] and on [Martin Fowler's blog][6] for some more piece of information.
It is not a new subject, but I wanted to write down the key concepts to sum it up as well as some insight of how to 
implement it.

## What is event sourcing

### Definition

With an event driven architecture, everything is an event. 
All the changes made to an entity have been made through multiple events. To trace back the actualized state of the entity,
you need to source (i.e. read from the beginning) all the events that happened on that entity.

One of the most common example would be a bank account, the sum of the events (deposit and withdrawal of money) correspond
to the actual balance of the account.

Let's see where and when this type of architecture can be useful.

### Advantages

Event sourcing is a bit different from traditional pattern where you have a DB always actualized with the last state of
your system's entities.

Looking at the [benefits of Event Sourcing][1], it can be summarized as such:

- Event driven architecture is best for system that needs to have a good **Audit** mechanism, but can be applied to many
  more.
- With all events saved, replaying the events allows building back the entity's state at different point in time.
    - Also, each event come with context (on the who, what, from) which makes it easier to follow the transformation of
      the entity for better debugging and observability.
- It is well suited for asynchronous interactions.
    - Multiple events can come in at the same time, and the service can sync or catch up independently with its event
      store
      (which can be of any type like Kafka, EventStoreDB, or a NoSQL DB).

## Key concepts

### Components

Here are the main components:

- An **Event store** which is where all the events generated by our system are stored
- A **System** containing: 
  - A **Decide** function to decide based on the business logic which event(s) to create
  - An **Apply** function to apply the change to the state

First, the system's input is a command sent by another user/system.
Then the events can be saved but also forwarded to other services.
Finally, depending on the interaction, you can trigger actions on state change. (retro-action)

### Diagram

Let's have a simple diagram of the core parts of an event-driven architecture and their interactions:

<div class="mermaid">
sequenceDiagram
  autonumber
  participant E as External
  participant A as Application
  participant S as Current state
  participant ES as Event Store
  E ->> A: New command
  opt Decide (Business logic)
    A -->> A: Create one or multiple events
  end
   A ->> ES:  Save event(s)
   A ->> S: Update state
  opt React to state change
    S ->> A: Apply triggered action
    Note over A: Act as an internal command <br> back to ❶
  end
</div>

For the big blocks, they represent:

- _External_: A user sending a command to the system
- _Application_: Our system that is using Event Driven Architecture
- _Current State_: Which is an abstract way to represent the current state of our system (makes the schema clearer)

The _"Decide"_ component which receives the command and create the events should behave independently of the _"Apply"_
component which only applies the events to modify the current state. This way, when replaying the events to build back 
the current state, you won't trigger new events.

## Implementation

### Design

Since the pattern may not talk to everyone, here would be a graph of the implementation.
It is a bit simplified and maybe limited, but the main actors are there.

As a note:

- The Event Store is a database type of component to store the events
- The Current State is another database type component that save the current state of the entities
- The rest of the component in the system are supposedly all in one application.

<div class="mermaid">
graph LR
  A((user)) -- send command--> B{Controller}
  subgraph system
  B <--> S[Business Service]
  S -- "❶" create event #2 --> E[(Event Store)]
  E --> H1[Event Handler #1]
  E --> H2[Event Handler #2]
  E --> H3[Event Handler #3]
  D -- "❸" trigger refresh --> D
  H2 -- "❹" apply event #2 --> D
  S -- "❷" request current state --> D
  D[(Current State)] -- "❺" return refreshed state --> S
end
</div>

The User can send command via an API, you would have a controller to interface with and pass the data to the Business Service
which hold the logic for the event creation. 

> In this context, one event is created and there is no retro-action

The current state is updated when you request the entity. The update is basically replaying the events, the corresponding
handlers will pick them up and apply the modification to the state.
The refreshed state could then be sent back to the User.

### Domain Driven Development

To put it simply, DDD ([Domain Driven Development][8]) is the separation of the code per domain instead of 
doing it per type of components.
Usually event sourcing works well with DDD because you apply events to an entity and
usually follow this pattern:

```bash
{Entity}{Verb}Event
# e.g. UserAddedEvent, InvoicePaidEvent, ProductUpdatedEvent
```

That entity can easily be matched to your business domain (Invoice, User, Product). Regrouping for one entity its corresponding
events, handlers, models, data sources adapters (for the current state), and other logic components will make a lot of sense
in a context where you need to deal with multiple entities from multiple domains.

### Command and Query Responsibility Segregation (CQRS)

When browsing through event sourcing topics, you'll often see [CQRS][9] which stands for Command and Query Responsibility Segregation.
Which is a pattern where the process for querying data and updating it (command) differs.

It works well with Event Driven, because to query the data you need to replay the events in order to get its current state.
But the creation of data goes through the emission of events.

> In opposition to a _traditional model_ where you store and retrieve the same model of the data from your database.

It is very well explained on the [microsoft CQRS documentation][10] and matches the event driven architecture way of handling data.
If you worry about the performance, you can optimize how to query the current state of your entity with caching,
so you don't have to replay all the events all the time.


[1]: https://www.eventstore.com/blog/what-is-event-sourcing "event store"
[2]: https://en.wikipedia.org/wiki/Event-driven_architecture "wikipedia event driven"
[3]: https://www.eventstore.com/event-sourcing "event store"
[4]: https://www.confluent.io/blog/event-sourcing-cqrs-stream-processing-apache-kafka-whats-connection/ "confluent"
[5]: https://docs.microsoft.com/en-us/azure/architecture/patterns/event-sourcing "microsoft azure"
[6]: https://martinfowler.com/eaaDev/EventSourcing.html "Martin fowler"
[7]: https://blog.engineering.publicissapient.fr/2017/01/16/event-sourcing-comprendre-les-bases-dun-systeme-evenementiel/ "french event sourcing"
[8]: https://en.wikipedia.org/wiki/Domain-driven_design "DDD"
[9]: https://en.wikipedia.org/wiki/Command%E2%80%93query_separation "CQRS"
[10]: https://docs.microsoft.com/en-us/azure/architecture/patterns/cqrs "microsoft CQRS"
